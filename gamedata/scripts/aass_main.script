--- Anomaly Advanced Storage System (AASS)
--- Author: Z30n_bh
--- Date: 08-02-2025
--- Game object is reffered to the the vanilla GameObject Class
--- AASSItem object is the fake LUA Game Object

-- AASS Mode is the toggle for the patched functions to execute AASS Logic during inventory management
AASS_MODE = false

-- AASS Containers
aass_stashes = {} -- Holds all the player created stashes and it's contents
aass_inventory = {} -- Holds all the instantiated AASSItems, generated when player opens an AASS stash

local aass_stash_buffer = { -- A staging buffer to hold game objects while in AASS Mode
    working_stash = nil,
    buffer_data = {}
}
local aass_category = {} -- Hold all the item category parameters like kind, vid ranges, callback functions

-- AASS Debug
local aass_debug_enabled = true
function aass_debug(string,...)
    if aass_debug_enabled then
        printf("AASS | " .. string, ...)
    end
end

-- Create a table entry for newly created player stash, stash_name will be used for RAT, called from callback
function create_aass_stash_entry(stash_name)
    return {
        aass_name = stash_name,
        aass_data = {}, -- Split into different categories, each categories have different ID Range, improves performance
        aass_used_vid = {} -- Stores used VID to reuse again, much faster than generating a new one
    }
end

function on_game_start()
    aass_category = aass_init_category() -- Initialize the category table
    RegisterScriptCallback("actor_on_stash_create", add_stash_to_aass)
    RegisterScriptCallback("actor_on_stash_remove", remove_stash_from_aass)
	--RegisterScriptCallback("ActorMenu_on_item_after_move",aass_transfer_item)
end


--------------------------------------------------------------------------------
--- Anomaly Advanced Storage System (AASS)
--------------------------------------------------------------------------------

-- Check if stash is player owned which loads aass
function is_aass_stash(box_id)
    return aass_stashes[box_id]
end

function is_aass_item(obj,obj_flag)
    local obj_id = obj
    if obj_flag then
        if not obj then return end -- not a valid obj
        obj_id = obj:id() -- If obj is an AASS object instead of a number
    end
    -- All AASSItem object have ID range above 100000, well outside vanilla object ID range
    if obj_id >= 100000 and obj_id <= 1900000 then return true end
end

-- Converts saved table data to AASSItem objects
function aass_generate_inventory(box_id)
    if aass_stashes[box_id] then -- Check for valid AASS stash
        local aass_stash_data = aass_stashes[box_id].aass_data
        aass_inventory = {} -- Clear all stale entries if they exist

        if aass_stash_data then
            for vid, item_table in pairs(aass_stash_data) do
                aass_debug("Generating AASS Item = %s | VID = %s", item_table.section, vid)
                aass_inventory[vid] = AASSItem(vid,item_table)
            end
        end
    end
end

-- Create an AASSItem object from a given vid, check should be made before passing valid vid
function create_aass_from_id(aass_vid)
    local item_data
    for box_id, aass_entry in pairs(aass_stashes) do
        item_data = aass_entry.aass_data[aass_vid]
        if item_data then break end
    end

    if not item_data then
        aass_debug("Item entry for AASS VID = %s not found!!!")
        return
    end

    return AASSItem(aass_vid,item_data)
end

-- Add game object to buffer, a staging area before converting to AASS Table data
function aass_update_stash_buffer(game_obj)
    local game_obj_id = game_obj:id()

    if not aass_stash_buffer.buffer_data[game_obj_id] then
        -- Store in buffer
        aass_stash_buffer.buffer_data[game_obj_id] = game_obj
        aass_debug("Item = %s - ID = %s, Added to AASS Buffer", game_obj:section(),game_obj_id)
    else
        -- Remove from buffer
        aass_stash_buffer.buffer_data[game_obj_id] = nil
        aass_debug("Item = %s - ID = %s, Removed from AASS Buffer", game_obj:section(),game_obj_id)
    end
end

function aass_update_working_stash(box_id)
    aass_stash_buffer.working_stash = box_id
end

-- Convert all the game objects in the aass_stash_buffer to AASS Table data
function aass_save_new_items()
    local box_id = aass_stash_buffer.working_stash
    local buffer_data = aass_stash_buffer.buffer_data

    -- If Buffer data is empty
    if not buffer_data then 
        aass_debug("Buffer data for box = %s is Empty, no items to save in AASS.",box_id)
        return 
    end

    for game_obj_id, game_obj in pairs(buffer_data) do
        local kind = SYS_GetParam(0, game_obj:section(), "kind")

        if game_obj and kind ~= "i_quest" then
            local cat, _, _ = unpack(get_item_category(game_obj))
            aass_debug("aass_save_new_items | cat = %s",cat)
            local new_aass_item_vid = generate_aass_vid(game_obj, box_id)
            local create_entry_func = aass_category[cat].create_entry
            local new_aass_item_data = create_entry_func(game_obj)
            local aass_stash_data_table = aass_stashes[box_id].aass_data

            if aass_debug_enabled then
                aass_debug("New AASS item VID = %s",new_aass_item_vid)
                for key,data in pairs(new_aass_item_data) do
                    aass_debug("new_aass_item_data | %s | %s",new_aass_item_vid, data)
                end
            end
        
            -- Update the stash data by adding the new entry
            aass_stash_data_table[new_aass_item_vid] = new_aass_item_data
            -- Release the game object from simulation
            alife_release_id(game_obj_id)
        end
    end
    
    --Clear Buffer data and working box id
    aass_stash_buffer.working_stash = nil
    aass_stash_buffer.buffer_data = {}
end

-- Create new item from table entry into the actor inventory
function aass_spawn_item_to_inventory(box_id,aass_obj)
    if is_aass_item(aass_obj,true) then
        aass_debug("Spawning AASS Item = %s | section = %s", aass_obj:name(), aass_obj:section())
        local cat, _, _ = unpack(get_item_category(aass_obj))
        local new_game_obj = aass_category[cat].spawn_item(aass_obj)

        if not new_game_obj then
            local stash_name = aass_stashes[box_id].aass_name
            aass_debug("Failed to spawn item = %s from stash = %s !!!", aass_obj:section(), stash_name)
        end
        -- Clear AASS Item entry for aass_stashes table
        local aass_stash = aass_stashes[box_id]
        local aass_vid = aass_obj:id()
        aass_stash.aass_data[aass_vid] = nil -- Clear Entry
        --local used_vids = aass_stash.aass_used_vid

        if aass_stash.aass_used_vid then
            -- If category alread has used vids
            if aass_stash.aass_used_vid[cat] then
                table.insert(aass_stash.aass_used_vid[cat],aass_vid) -- append to existing list
            else
                aass_stash.aass_used_vid[cat] = {aass_vid} -- save VID for new category
            end
        else
            aass_stash.aass_used_vid[cat] = {aass_vid} -- Save Used VID into a new entry
        end

        --aass_debug("New Game Object = %s | Object ID = %s",new_game_obj:section(), new_game_obj:id())
        -- Return game_obj to UIInventory.Action_Move
        return new_game_obj
    end
end

--------------------------------------------------------------------------------
--- AASS Category - Create Entry and Spawn Item definitions
--------------------------------------------------------------------------------

function aass_init_category()
    return {
        ["weapons"] = {
            kind = { "w_sniper", "w_rifle", "w_smg", "w_shotgun", "w_pistol", "w_melee", "w_misc", "w_explosive", "w_base" },
            vid_start = 100000,
            vid_end = 199999,
            create_entry = create_weapon_aass_entry,
            spawn_item = spawn_weapon_from_aass
        },
        ["outfits"] = {
            kind = { "o_light", "o_medium", "o_heavy",  "o_sci", "o_helmet" },
            vid_start = 200000,
            vid_end = 299999,
            create_entry = create_outfit_aass_entry,
            spawn_item = spawn_outfit_from_aass
        },
        ["ammo"] = {
            kind = { "w_ammo" },
            vid_start = 300000,
            vid_end = 399999,
            create_entry = create_ammo_aass_entry,
            spawn_item = spawn_ammo_from_aass
        },
        ["trophies"] = {
            kind = { "i_arty", "i_arty_junk", "i_arty_cont", "i_mutant_part", "i_mutant_belt" },
            vid_start = 400000,
            vid_end = 499999,
            create_entry = create_trophies_aass_entry,
            spawn_item = spawn_trophies_from_aass
        },
        ["devices"] = {
            kind = { "i_device", "i_tool", "i_repair", "i_kit" },
            vid_start = 500000,
            vid_end = 599999,
            create_entry = create_devices_aass_entry,
            spawn_item = spawn_devices_from_aass
        },
        ["consumables"] = {
            kind = { "i_mutant_raw", "i_mutant_cooked", "i_food", "i_drink" },
            vid_start = 600000,
            vid_end = 699999,
            create_entry = create_multi_aass_entry,
            spawn_item = spawn_multi_from_aass
        },
        ["medical"] = {
            kind = { "i_medical" },
            vid_start = 700000,
            vid_end = 799999,
            create_entry = create_multi_aass_entry,
            spawn_item = spawn_multi_from_aass
        },
        ["upgrades"] = {
            kind = { "i_upgrade" },
            vid_start = 800000,
            vid_end = 899999,
            create_entry = create_multi_aass_entry,
            spawn_item = spawn_multi_from_aass
        },
        ["misc"] = { -- Also Contains items with no specific kind assigned
            kind = { "i_letter", "i_misc", "i_part" },
            vid_start = 900000,
            vid_end = 1900000, -- Extended range for misc as there can be a lot of items in this category
            create_entry = create_misc_aass_entry,
            spawn_item = spawn_misc_aass_entry
        }
    }
end

--- Creating Item entry for items based on category
function create_weapon_aass_entry(game_obj)
    local item_kind = SYS_GetParam(0, game_obj:section(), "kind")

    if item_kind == "w_melee" then
        return {section = game_obj:section(), clsid = game_obj:clsid(), condition = game_obj:condition()}
    end

    if item_kind == "w_misc" or item_kind == "w_explosive" then -- For Scopes, silencers, grenade launchers, Explosives and Tactical Kits
        return {section = game_obj:section(), clsid = game_obj:clsid()}
    end

    -- Placeholder, still not sure what w_base does
    if item_kind == "w_base" then
        return {section = game_obj:section(), clsid = game_obj:clsid()}
    end

    -- For Weapons
    local weapon_data = {}
    weapon_data.section = game_obj:section()
    weapon_data.condition = game_obj:condition()
    weapon_data.clsid = game_obj:clsid()
    weapon_data.installed_upgrades = utils_item.get_upgrades_installed(game_obj, nil, false)

    -- Check if weapon has attachments
    local weapon_attachments = { scope = nil, sil = nil, gl = nil}

    weapon_attachments.scope = utils_item.get_attached_scope(game_obj)
    weapon_attachments.sil = utils_item.get_attached_silencer(game_obj)
    weapon_attachments.gl = utils_item.get_attached_gl(game_obj)

    weapon_data.weapon_attachments = weapon_attachments
    weapon_data.misc_props = {}

    return weapon_data
end

function create_outfit_aass_entry(game_obj)
    local outfit_data = {}
    outfit_data.section = game_obj:section()
    outfit_data.condition = game_obj:condition()
    outfit_data.clsid = game_obj:clsid()
    outfit_data.installed_upgrades = utils_item.get_upgrades_installed(game_obj, nil, false)
    outfit_data.misc_props = {}

    return outfit_data
end

function create_ammo_aass_entry(game_obj)
    return {section = game_obj:section(), clsid = game_obj:clsid(), amount = game_obj:ammo_get_count()}
end

function create_trophies_aass_entry(game_obj)
    -- Contains Artifacts, pelts and containers
    return {section = game_obj:section(), clsid = game_obj:clsid(), condition = game_obj:condition()}
end

function create_devices_aass_entry(game_obj)
    -- Check if item is multi-use or condition dependent
    local use_condition = SYS_GetParam(1, game_obj:section(), "use_condition") or false
    local devices_entry = {section = game_obj:section(), clsid = game_obj:clsid()}

    if use_condition then
        devices_entry.condition = game_obj:condition()
    else
        devices_entry.remaining_uses = game_obj:get_remaining_uses()
    end

    return devices_entry
end

-- General entry for all items that are multi-uses with no special properties
function create_multi_aass_entry(game_obj)
    return {section = game_obj:section(), clsid = game_obj:clsid(), remaining_uses = game_obj:get_remaining_uses()}
end

-- PLACEHOLDER function for misc items, these items range from simple scrap metal to other mod added items
-- Items may have custom functors, need to account for that
-- This is also the default entry for items with unkown kind
function create_misc_aass_entry(game_obj)
    return {section = game_obj:section(), clsid = game_obj:clsid(), condition = game_obj:condition(), misc_props = {}}
end

--- Spawn New Item object from AASS ---

-- Set Weapon conditon and upgrades depending on the kind of weapon
function spawn_weapon_from_aass(aass_obj)
    local item_kind = SYS_GetParam(0, aass_obj:section(), "kind")

    if item_kind == "w_misc" or item_kind == "w_explosive" or item_kind == "w_base" then
        return alife_create_item(aass_obj:section())
    end

    if item_kind == "w_melee" then
        local condition = aass_obj:condition()
        return alife_create_item(aass_obj:section(), db.actor, {
            ["cond"] = condition
        })
    end

    -- For Weapons
    local condition = aass_obj:condition()
    local installed_upgrades = aass_obj.installed_upgrades
    local weapon_attachments = aass_obj.weapon_attachments

    local game_obj = alife_create_item(aass_obj:section(), db.actor, {
        ["cond"] = condition
    })

    -- Install Upgrades
    if installed_upgrades then
        for _, upgr_section in ipairs(installed_upgrades) do
            game_obj:install_upgrade(upgr_section)
        end
    end

    -- Install Attachments
    -- game_obj:weapon_addon_attach(addon)
    -- Here addon is an object, so weapon attachments need to be saved first in aass_entry
    -- For now just a placeholder for testing
    -- ADD ATTACHMENT SUPPORT!!!

    return game_obj
end

-- Set Outfit conditon and upgrades
function spawn_outfit_from_aass(aass_obj)
    local condition = aass_obj:condition()
    local installed_upgrades = aass_obj.installed_upgrades

    local game_obj = alife_create_item(aass_obj:section(), db.actor, {
        ["cond"] = condition
    })
    
    -- Install Upgrades
    if installed_upgrades then
        for _, upgr_section in ipairs(installed_upgrades) do
            game_obj:install_upgrade(upgr_section)
        end
    end

    return game_obj
end

-- Create Ammo box from saved amount
function spawn_ammo_from_aass(aass_obj)
    local amount = aass_obj.amount

    return alife_create_item(aass_obj:section(), db.actor, {
        ["ammo"] = amount
    })
end

function spawn_trophies_from_aass(aass_obj)
    local condition = aass_obj:condition()

    return alife_create_item(aass_obj:section(), db.actor, {
        ["cond"] = condition
    })
end

function spawn_devices_from_aass(aass_obj)
    local condition = aass_obj:condition()
    local remaining_uses = aass_obj.remaining_uses

    if condition then
        return alife_create_item(aass_obj:section(), db.actor, {
            ["cond"] = condition
        })
    else
        return alife_create_item(aass_obj:section(), db.actor, {
            ["uses"] = remaining_uses,
        })
    end
end

-- Generic function for multi-uses items with no special props
function spawn_multi_from_aass(aass_obj)
    local remaining_uses = aass_obj.remaining_uses

    return alife_create_item(aass_obj:section(), db.actor, {
        ["uses"] = remaining_uses,
    })
end

function spawn_misc_aass_entry(aass_obj)
    local condition = aass_obj:condition()

    return alife_create_item(aass_obj:section(), db.actor, {
        ["cond"] = condition,
    })
end



-- Create a new entry table in aass_stashes table for an item stored in an aass stash
function aass_store_new_item(game_obj,aass_stash_id)
    
end


--------------------------------------------------------------------------------
--- Utilities
--------------------------------------------------------------------------------

--- AASS VID Generator
-- Generate a unique VID for a new item stored in an aass stash
function generate_aass_vid(game_obj, stash_id)
    local cat, start_vid, end_vid = unpack(get_item_category(game_obj))
    --local used_vids = aass_stashes[stash_id].aass_used_vid
    local reused_vid = aass_get_resused_vid(cat,stash_id)

    if reused_vid then
        -- If VID Available for reuse
        aass_debug("Reusing VID for Item = %s | VID = %s | Category = %s", 
                    game_obj:section(), reused_vid, cat)
        return reused_vid
    end

    -- Generate New VID for the new item
    local vid_taken = true
    local new_vid

    while vid_taken do
        --keep generating new vid and return if unique
        -- Collisions should be extremely rare given the very large VID Range
        new_vid = math.random(start_vid,end_vid)

        if not aass_stashes[stash_id].aass_data[new_vid] then
            vid_taken = false
        end
    end

    aass_debug("New VID generated for Item = %s, category = %s, VID = %s",
                game_obj:section(), cat, new_vid)

    return new_vid
end

function aass_get_resused_vid(category,stash_id)
    local reused_vids = aass_stashes[stash_id].aass_used_vid

    if reused_vids then
        for cat,vid_table in pairs(reused_vids) do
            if cat == category and vid_table then
                return table.remove(vid_table,1)
            end
        end
    end
end

function get_item_category(game_obj)
    local obj_kind = SYS_GetParam(0, game_obj:section(), "kind") or "NA"
    aass_debug("Item = %s | Kind = %s", game_obj:section(), obj_kind)
    local default_start_vid = aass_category["misc"].vid_start
    local default_end_vid = aass_category["misc"].vid_end
    local default_cat = {"misc", default_start_vid, default_end_vid}

    -- Default to misc if kind not defined in config file
    if obj_kind == "NA" then 
        aass_debug("NA Category for Item = %s , Returning default category misc", game_obj:section())    
        return default_cat
    end

    for cat,data in pairs(aass_category) do
        for _,kind in ipairs(data.kind) do
            if obj_kind == kind then
                aass_debug("Selected Category for Item = %s | Category = %s , start_vid = %s, end_vid = %s",
                            game_obj:section(), cat, data.vid_start, data.vid_end)
                return {cat, data.vid_start, data.vid_end}
            end
        end
    end

    aass_debug("No Category match for Item = %s , returning default misc category")
    return default_cat
end



--------------------------------------------------------------------------------
--- AASS Callbacks
--------------------------------------------------------------------------------

-- Manage Player Created Stashes and create new entry in aass_data
function add_stash_to_aass(data)
    local stash_id = data.stash_id
    local stash_name = data.stash_name

    if not aass_stashes[stash_id] then
        aass_debug("New Stash Added = %s | ID = %s", stash_name,stash_id)
        aass_stashes[stash_id] = create_aass_stash_entry(stash_name)
    end
end

function remove_stash_from_aass(data)
    for stash_id, stash_data in pairs(aass_stashes) do
        if stash_id == data.stash_id then
            aass_debug("Removing Stash = %s | ID = %s", stash_data.aass_name,stash_id)
            aass_stashes[stash_id] = nil
        end
    end
end


class "AASSItem"

function AASSItem:__init(vid,item_data)
    -- Init an AASSItem object when loading aass_data from saved player stash box
    -- AASSItem acts like a generic fake game object to display Item Icon in the UIInventory window
    -- AASSItem should also integrate other mods that display custom icons like WPO, Icon improvement Mods, Etc
    -- AASSItem will only suppport move feature for now, will integrate dissassemble, weapon attachments and other features later on
    self.aass_vid = vid
    self.aass_clsid = item_data.clsid
    self.aass_section = item_data.section
    self.aass_condition = item_data.condition or 1
    self.installed_upgrades = item_data.install_upgrades or nil
    self.weapon_attachments = item_data.weapon_attachments or nil
    self.amount = item_data.amount or nil
    self.remaining_uses = item_data.remaining_uses or nil
    self.misc_props = item_data.misc_props or nil
end

function AASSItem:__finalize()

end

function AASSItem:name()
    return SYS_GetParam(0, self.aass_section, "inv_name")
end

function AASSItem:section()
    return self.aass_section
end

function AASSItem:weight()
    return SYS_GetParam(0, self.aass_section, "inv_weight")
end

-- Returns the aass_data.vid
function AASSItem:id()
    return self.aass_vid
end

function AASSItem:condition()
    return self.aass_condition
end

function AASSItem:clsid()
    --return SYS_GetParam(0, self.aass_section, "class")
    return self.aass_clsid
end

-- For multiuse items store the remaining uses in database
function AASSItem:get_remaining_uses()
    return self.remaining_uses
end

-- For Ammo
function AASSItem:ammo_get_count()
    return self.amount
end

-- Iterate over installed upgrades
function AASSItem:iterate_installed_upgrades(func)
    local installed_upgrades = self.install_upgrades
    
    -- No installed Upgrades
    if not installed_upgrades then return false end

    for _,upgr_sec in ipairs(installed_upgrades) do
        local found = func(upgr_sec)
        if found then break end
    end
end

-- PLACEHOLDER
function AASSItem:weapon_scope_status()
    return 1
end

function AASSItem:weapon_silencer_status()
    return 1
end

function AASSItem:weapon_is_silencer()
    return false
end

function AASSItem:weapon_grenadelauncher_status()
    return 1
end